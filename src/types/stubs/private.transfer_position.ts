/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Transfers a positions from one subaccount to another, owned by the same wallet.
 *
 * The transfer is executed as a pair of orders crossing each other.
 * The maker order is created first, followed by a taker order crossing it.
 * The order amounts, limit prices and instrument name must be the same for both orders.
 * Fee is not charged and a zero `max_fee` must be signed.
 * The maker order is forcibly considered to be `reduce_only`, meaning it can only reduce the position size.
 */
export type PrivateTransferPosition = PrivateTransferPositionJSONRPCSchema;
export type Method = 'private/transfer_position';
/**
 * Order amount in units of the base
 */
export type Amount = string;
/**
 * Order direction
 */
export type Direction = 'buy' | 'sell';
/**
 * Instrument name
 */
export type InstrumentName = string;
/**
 * Limit price in quote currency.<br />This field is still required for market orders because it is a component of the signature. However, market orders will not leave a resting order in the book in case of a partial fill.
 */
export type LimitPrice = string;
/**
 * Max fee in units of the quote currency. Order will be rejected if the supplied max fee is below the estimated fee for this order.
 */
export type MaxFee = string;
/**
 * Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_6_digits> (e.g. 1695836058725001, where 001 is the random number)
 */
export type Nonce = number;
/**
 * Etherium signature of the order
 */
export type Signature = string;
/**
 * Unix timestamp in seconds. Order signature becomes invalid after this time, and the system will cancel the order.Expiry MUST be at least 5 min from now.
 */
export type SignatureExpirySec = number;
/**
 * Owner wallet address or registered session key that signed order
 */
export type Signer = string;
/**
 * Subaccount ID
 */
export type SubaccountId = number;
/**
 * Public key (wallet) of the account
 */
export type Wallet = string;
/**
 * Order amount in units of the base
 */
export type Amount1 = string;
/**
 * Average fill price
 */
export type AveragePrice = string;
/**
 * If cancelled, reason behind order cancellation
 */
export type CancelReason =
  | ''
  | 'user_request'
  | 'mmp_trigger'
  | 'insufficient_margin'
  | 'signed_max_fee_too_low'
  | 'cancel_on_disconnect'
  | 'ioc_or_market_partial_fill'
  | 'session_key_deregistered'
  | 'subaccount_withdrawn'
  | 'compliance';
/**
 * Creation timestamp (in ms since Unix epoch)
 */
export type CreationTimestamp = number;
/**
 * Order direction
 */
export type Direction1 = 'buy' | 'sell';
/**
 * Total filled amount for the order
 */
export type FilledAmount = string;
/**
 * Instrument name
 */
export type InstrumentName1 = string;
/**
 * Whether the order was generated through `private/transfer_position`
 */
export type IsTransfer = boolean;
/**
 * Optional user-defined label for the order
 */
export type Label = string;
/**
 * Last update timestamp (in ms since Unix epoch)
 */
export type LastUpdateTimestamp = number;
/**
 * Limit price in quote currency
 */
export type LimitPrice1 = string;
/**
 * Max fee in units of the quote currency
 */
export type MaxFee1 = string;
/**
 * Whether the order is tagged for market maker protections
 */
export type Mmp = boolean;
/**
 * Unique nonce defined as <UTC_timestamp in ms><random_number_up_to_3_digits> (e.g. 1695836058725001, where 001 is the random number)
 */
export type Nonce1 = number;
/**
 * Total order fee paid so far
 */
export type OrderFee = string;
/**
 * Order ID
 */
export type OrderId = string;
/**
 * Order status
 */
export type OrderStatus = 'open' | 'filled' | 'rejected' | 'cancelled' | 'expired';
/**
 * Order type
 */
export type OrderType = 'limit' | 'market';
/**
 * Ethereum signature of the order
 */
export type Signature1 = string;
/**
 * Signature expiry timestamp
 */
export type SignatureExpirySec1 = number;
/**
 * Owner wallet address or registered session key that signed order
 */
export type Signer1 = string;
/**
 * Subaccount ID
 */
export type SubaccountId1 = number;
/**
 * Time in force
 */
export type TimeInForce = 'gtc' | 'post_only' | 'fok' | 'ioc';
/**
 * Order direction
 */
export type Direction2 = 'buy' | 'sell';
/**
 * Index price of the underlying at the time of the trade
 */
export type IndexPrice = string;
/**
 * Instrument name
 */
export type InstrumentName2 = string;
/**
 * Whether the trade was generated through `private/transfer_position`
 */
export type IsTransfer1 = boolean;
/**
 * Optional user-defined label for the order
 */
export type Label1 = string;
/**
 * Role of the user in the trade
 */
export type LiquidityRole = 'maker' | 'taker';
/**
 * Mark price of the instrument at the time of the trade
 */
export type MarkPrice = string;
/**
 * Order ID
 */
export type OrderId1 = string;
/**
 * Realized PnL for this trade
 */
export type RealizedPnl = string;
/**
 * Subaccount ID
 */
export type SubaccountId2 = number;
/**
 * Trade timestamp (in ms since Unix epoch)
 */
export type Timestamp = number;
/**
 * Amount filled in this trade
 */
export type TradeAmount = string;
/**
 * Fee for this trade
 */
export type TradeFee = string;
/**
 * Trade ID
 */
export type TradeId = string;
/**
 * Price at which the trade was filled
 */
export type TradePrice = string;
/**
 * Blockchain transaction hash
 */
export type TxHash = string | null;
/**
 * Blockchain transaction status
 */
export type TxStatus = 'requested' | 'pending' | 'settled' | 'reverted' | 'ignored';

export interface PrivateTransferPositionJSONRPCSchema {
  request: PrivateTransferPositionRequestSchema;
  response: PrivateTransferPositionResponseSchema;
}
export interface PrivateTransferPositionRequestSchema {
  id?: string | number;
  method: Method;
  params: PrivateTransferPositionParamsSchema;
}
export interface PrivateTransferPositionParamsSchema {
  maker_params: TradeModuleParamsSchema;
  taker_params: TradeModuleParamsSchema1;
  wallet: Wallet;
}
/**
 * Maker order parameters and signature. Maximum transfer amount is limited by the size of the maker position. Transfers that increase the maker's position size are not allowed.
 */
export interface TradeModuleParamsSchema {
  amount: Amount;
  direction: Direction;
  instrument_name: InstrumentName;
  limit_price: LimitPrice;
  max_fee: MaxFee;
  nonce: Nonce;
  signature: Signature;
  signature_expiry_sec: SignatureExpirySec;
  signer: Signer;
  subaccount_id: SubaccountId;
}
/**
 * Taker order parameters and signature
 */
export interface TradeModuleParamsSchema1 {
  amount: Amount;
  direction: Direction;
  instrument_name: InstrumentName;
  limit_price: LimitPrice;
  max_fee: MaxFee;
  nonce: Nonce;
  signature: Signature;
  signature_expiry_sec: SignatureExpirySec;
  signer: Signer;
  subaccount_id: SubaccountId;
}
export interface PrivateTransferPositionResponseSchema {
  id: string | number;
  result: PrivateTransferPositionResultSchema;
}
export interface PrivateTransferPositionResultSchema {
  maker_order: OrderResponseSchema;
  maker_trade: TradeResponseSchema;
  taker_order: OrderResponseSchema1;
  taker_trade: TradeResponseSchema1;
}
export interface OrderResponseSchema {
  amount: Amount1;
  average_price: AveragePrice;
  cancel_reason: CancelReason;
  creation_timestamp: CreationTimestamp;
  direction: Direction1;
  filled_amount: FilledAmount;
  instrument_name: InstrumentName1;
  is_transfer: IsTransfer;
  label: Label;
  last_update_timestamp: LastUpdateTimestamp;
  limit_price: LimitPrice1;
  max_fee: MaxFee1;
  mmp: Mmp;
  nonce: Nonce1;
  order_fee: OrderFee;
  order_id: OrderId;
  order_status: OrderStatus;
  order_type: OrderType;
  signature: Signature1;
  signature_expiry_sec: SignatureExpirySec1;
  signer: Signer1;
  subaccount_id: SubaccountId1;
  time_in_force: TimeInForce;
}
export interface TradeResponseSchema {
  direction: Direction2;
  index_price: IndexPrice;
  instrument_name: InstrumentName2;
  is_transfer: IsTransfer1;
  label: Label1;
  liquidity_role: LiquidityRole;
  mark_price: MarkPrice;
  order_id: OrderId1;
  realized_pnl: RealizedPnl;
  subaccount_id: SubaccountId2;
  timestamp: Timestamp;
  trade_amount: TradeAmount;
  trade_fee: TradeFee;
  trade_id: TradeId;
  trade_price: TradePrice;
  tx_hash: TxHash;
  tx_status: TxStatus;
}
export interface OrderResponseSchema1 {
  amount: Amount1;
  average_price: AveragePrice;
  cancel_reason: CancelReason;
  creation_timestamp: CreationTimestamp;
  direction: Direction1;
  filled_amount: FilledAmount;
  instrument_name: InstrumentName1;
  is_transfer: IsTransfer;
  label: Label;
  last_update_timestamp: LastUpdateTimestamp;
  limit_price: LimitPrice1;
  max_fee: MaxFee1;
  mmp: Mmp;
  nonce: Nonce1;
  order_fee: OrderFee;
  order_id: OrderId;
  order_status: OrderStatus;
  order_type: OrderType;
  signature: Signature1;
  signature_expiry_sec: SignatureExpirySec1;
  signer: Signer1;
  subaccount_id: SubaccountId1;
  time_in_force: TimeInForce;
}
export interface TradeResponseSchema1 {
  direction: Direction2;
  index_price: IndexPrice;
  instrument_name: InstrumentName2;
  is_transfer: IsTransfer1;
  label: Label1;
  liquidity_role: LiquidityRole;
  mark_price: MarkPrice;
  order_id: OrderId1;
  realized_pnl: RealizedPnl;
  subaccount_id: SubaccountId2;
  timestamp: Timestamp;
  trade_amount: TradeAmount;
  trade_fee: TradeFee;
  trade_id: TradeId;
  trade_price: TradePrice;
  tx_hash: TxHash;
  tx_status: TxStatus;
}
